[
  {
    "question": "Що цей код виведе в консоль?",
    "code": "function Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.speak = function () {\n  return this.name + ' makes a noise.';\n}\n\nfunction Dog(name) {\n  Animal.call(this, name);\n}\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\nlet dog = new Dog('Mitzie');\ndog.speak();",
    "info": "<p>Цей код ілюструє прототипне наслідування в JavaScript. Спочатку створюється функція конструктора <code>Animal</code> із методом <code>speak</code> у її прототипі. Потім створюється функція конструктора <code>Dog</code>, яка наслідує від <code>Animal</code>. За допомогою <code>Object.create</code> створюється новий об'єкт з прототипом <code>Animal</code> для <code>Dog</code>. Коли викликається метод <code>speak</code> для екземпляра <code>Dog</code>, він виводить ім'я собаки та фразу, зазначену в методі <code>speak</code> прототипу <code>Animal</code>.</p>",
    "options": [
      "Mitzie makes a noise.",
      "Dog makes a noise.",
      "TypeError",
      "undefined"
    ],
    "answer": "Mitzie makes a noise."
  },
  {
    "question": "Що цей код виведе в консоль?",
    "code": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => {\n    console.log(i); \n  }, 1000);\n}",
    "info": "<p>Цей код демонструє класичну проблему замикань у JavaScript у контексті асинхронних функцій. Використовуючи <code>var</code>, змінна <code>i</code> є глобальною для функції, в якій вона була оголошена. Тому, коли <code>setTimeout</code> виконується, <code>i</code> має останнє значення після завершення циклу. У цьому випадку всі асинхронні виклики <code>console.log</code> виведуть '3'. Якщо замінити <code>var</code> на <code>let</code>, кожна ітерація циклу матиме свою копію <code>i</code>, і виведе очікувані значення 0, 1, 2.</p>",
    "options": [
      "0 1 2",
      "3 3 3",
      "undefined",
      "0 0 0"
    ],
    "answer": "3 3 3"
  },
  {
    "question": "Що цей код виведе в консоль?",
    "code": "console.log(typeof null);",
    "info": "<p>При використанні оператора <code>typeof</code> з <code>null</code> у JavaScript, він повертає 'object'. Ця поведінка є результатом реалізації в мові JavaScript, де 'null' представлено як вказівник, що не вказує ні на що, і має значення 0. У ранніх версіях JavaScript, типи даних були представлені за допомогою нижніх бітів. Так, 'object' мав нульовий тег типу, тому 'null', яке є нульовим вказівником, помилково вважалося об'єктом. Ця поведінка не була виправлена у зв'язку з турботою про зворотну сумісність, оскільки виправлення могло б порушити існуючий код, який покладався на цю особливість.</p>",
    "options": [
      "null",
      "object",
      "true",
      "SyntaxError"
    ],
    "answer": "object"
  },
  {
    "question": "Що цей код виведе в консоль?",
    "code": "console.log(0.1 + 0.2 === 0.3);",
    "info": "<p>У JavaScript вираз 0.1 + 0.2 === 0.3 повертає false через особливості представлення і обчислення чисел з плаваючою комою в комп'ютерах. </p> <p>Коли ви виконуєте додавання 0.1 і 0.2, результат не є точно 0.3 через двійкове представлення цих чисел. Двійкова система не може точно представити деякі десяткові дроби, такі як 0.1, 0.2, або 0.3. Замість цього, вони представляються як наближення, що призводить до невеликих похибок при обчисленні. </p> <p>Коли JavaScript виконує 0.1 + 0.2, результат стає приблизно 0.30000000000000004, а не точно 0.3. Тому, коли ви порівнюєте це з 0.3 за допомогою строгого рівності (===), яке перевіряє на точну рівність, результат стає false.</p>",
    "options": [
      "SyntaxError",
      "true",
      "false",
      "NaN"
    ],
    "answer": "false"
  },
  {
    "question": "Що цей код виведе в консоль?",
    "code": "console.log(1 + '2' + '2');",
    "info": "<p>У JavaScript оператор +, який використовується для додавання чисел, також використовується для з'єднання рядків. Коли ви додаєте щось до рядка, результатом буде рядок. </p> <p>У цьому випадку, '1' + '2' стає '12'. Потім '12' + '2' стає '122'.</p>",
    "options": [
      "SyntaxError",
      "122",
      "NaN",
      "32"
    ],
    "answer": "122"
  },
  {
    "question": "Що цей код виведе в консоль?",
    "code": "console.log(1 + +'2' + '2');",
    "info": "<p>В JavaScript, цей код <code>console.log(1 + +'2' + '2')</code> працює наступним чином:</p><ol><li><code>+'2'</code>: Унарний плюс (<code>+</code>) перетворює рядок <code>'2'</code> у число, тобто <code>2</code>.</li><li><code>1 + 2</code>: Тепер відбувається додавання чисел, тобто <code>1 + 2</code>, що дає <code>3</code>.</li><li><code>3 + '2'</code>: Нарешті, число <code>3</code> додається до рядка <code>'2'</code>. У JavaScript, коли додається число до рядка, число перетворюється на рядок, тому результатом буде конкатенація рядків, а саме <code>'32'</code>.</li></ol><p>Отже, результатом <code>console.log(1 + +'2' + '2')</code> буде <code>'32'</code>.</p>",
    "options": [
      "122",
      "SyntaxError",
      "NaN",
      "32"
    ],
    "answer": "32"
  },
  {
    "question": "Що цей код виведе в консоль?",
    "code": "console.log([] == ![]);",
    "info": "<p>Цей приклад JavaScript демонструє автоматичне перетворення типів. Ось як це працює:</p><ol><li>Спочатку, <code>![]</code> (заперечення пустого масиву) перетворюється в булевий тип. Будь-який об'єкт, включаючи пустий масив, є <code>true</code> в булевому контексті, тому <code>![]</code> стає <code>false</code>.</li><li>Потім, при порівнянні <code>[] == false</code>, JavaScript спочатку перетворює <code>false</code> в числовий тип, отримуючи <code>0</code>.</li><li>Далі, пустий масив <code>[]</code> також перетворюється в числовий тип. При перетворенні пустого масиву в число, він стає <code>0</code>.</li><li>Таким чином, порівняння перетворюється на <code>0 == 0</code>, що є <code>true</code>.</li></ol><p>Тому виведенням в консоль буде <code>true</code>.</p>",
    "options": [
      "true",
      "false",
      "TypeError",
      "undefined"
    ],
    "answer": "true"
  }
]
